// Generated by protoc-gen-vala 0.1.0 from protobuf/cast_channel.proto, do not edit

public enum SignatureAlgorithm
{
    UNSPECIFIED = 0,
    RSASSA_PKCS1v15 = 1,
    RSASSA_PSS = 2,
}
public static string SignatureAlgorithm_to_string (SignatureAlgorithm value)
{
    switch (value)
    {
    case SignatureAlgorithm.UNSPECIFIED:
        return "UNSPECIFIED";
    case SignatureAlgorithm.RSASSA_PKCS1v15:
        return "RSASSA_PKCS1v15";
    case SignatureAlgorithm.RSASSA_PSS:
        return "RSASSA_PSS";
    default:
        return "%d".printf (value);
    }
}

public enum HashAlgorithm
{
    SHA1 = 0,
    SHA256 = 1,
}
public static string HashAlgorithm_to_string (HashAlgorithm value)
{
    switch (value)
    {
    case HashAlgorithm.SHA1:
        return "SHA1";
    case HashAlgorithm.SHA256:
        return "SHA256";
    default:
        return "%d".printf (value);
    }
}

public class CastMessage : Protobuf.Message
{
    public enum ProtocolVersion
    {
        CASTV2_1_0 = 0,
    }
    public static string ProtocolVersion_to_string (ProtocolVersion value)
    {
        switch (value)
        {
        case ProtocolVersion.CASTV2_1_0:
            return "CASTV2_1_0";
        default:
            return "%d".printf (value);
        }
    }
    public enum PayloadType
    {
        STRING = 0,
        BINARY = 1,
    }
    public static string PayloadType_to_string (PayloadType value)
    {
        switch (value)
        {
        case PayloadType.STRING:
            return "STRING";
        case PayloadType.BINARY:
            return "BINARY";
        default:
            return "%d".printf (value);
        }
    }
    public ProtocolVersion protocol_version;
    public string source_id;
    public string destination_id;
    public string namespace;
    public PayloadType payload_type;
    public string payload_utf8;
    public GLib.ByteArray payload_binary;

    public CastMessage ()
    {
        this.protocol_version = 0;
        this.source_id = "";
        this.destination_id = "";
        this.namespace = "";
        this.payload_type = 0;
        this.payload_utf8 = "";
        this.payload_binary = null;
    }

    public CastMessage.from_data (Protobuf.DecodeBuffer buffer, ssize_t data_length = -1)
    {
        decode (buffer, data_length);
    }

    public override bool decode (Protobuf.DecodeBuffer buffer, ssize_t data_length = -1)
    {
        size_t end;
        if (data_length < 0)
            end = buffer.buffer.length;
        else
            end = buffer.read_index + data_length;
        var have_protocol_version = false;
        var have_source_id = false;
        var have_destination_id = false;
        var have_namespace = false;
        var have_payload_type = false;

        this.protocol_version = 0;
        this.source_id = "";
        this.destination_id = "";
        this.namespace = "";
        this.payload_type = 0;
        this.payload_utf8 = "";
        this.payload_binary = null;
        while (buffer.read_index < end)
        {
            var key = buffer.decode_varint ();
            var wire_type = key & 0x7;
            var field_number = key >> 3;

            if (field_number == 1 && wire_type == 0)
            {
                this.protocol_version = (ProtocolVersion) buffer.decode_varint ();
                have_protocol_version = true;
            }
            else if (field_number == 2 && wire_type == 2)
            {
                this.source_id = buffer.decode_string ((size_t) buffer.decode_varint ());
                have_source_id = true;
            }
            else if (field_number == 3 && wire_type == 2)
            {
                this.destination_id = buffer.decode_string ((size_t) buffer.decode_varint ());
                have_destination_id = true;
            }
            else if (field_number == 4 && wire_type == 2)
            {
                this.namespace = buffer.decode_string ((size_t) buffer.decode_varint ());
                have_namespace = true;
            }
            else if (field_number == 5 && wire_type == 0)
            {
                this.payload_type = (PayloadType) buffer.decode_varint ();
                have_payload_type = true;
            }
            else if (field_number == 6 && wire_type == 2)
                this.payload_utf8 = buffer.decode_string ((size_t) buffer.decode_varint ());
            else if (field_number == 7 && wire_type == 2)
                this.payload_binary = buffer.decode_bytes ((size_t) buffer.decode_varint ());
            else
                this.unknown_fields.prepend (buffer.decode_unknown_field (key));
        }

        if (buffer.read_index != end)
            buffer.error = true;
        else if (!have_protocol_version || !have_source_id || !have_destination_id || !have_namespace || !have_payload_type)
            buffer.error = true;

        return !buffer.error;
    }

    public override size_t encode (Protobuf.EncodeBuffer buffer)
    {
        size_t n_written = 0;

        foreach (var f in this.unknown_fields)
            n_written += buffer.encode_unknown_field (f);
        if (this.payload_binary != null)
        {
            var payload_binary_length = buffer.encode_bytes (this.payload_binary);
            n_written += payload_binary_length;
            n_written += buffer.encode_varint (payload_binary_length);
            n_written += buffer.encode_varint (58);
        }
        if (this.payload_utf8 != "")
        {
            var payload_utf8_length = buffer.encode_string (this.payload_utf8);
            n_written += payload_utf8_length;
            n_written += buffer.encode_varint (payload_utf8_length);
            n_written += buffer.encode_varint (50);
        }
        n_written += buffer.encode_varint (this.payload_type);
        n_written += buffer.encode_varint (40);
        var namespace_length = buffer.encode_string (this.namespace);
        n_written += namespace_length;
        n_written += buffer.encode_varint (namespace_length);
        n_written += buffer.encode_varint (34);
        var destination_id_length = buffer.encode_string (this.destination_id);
        n_written += destination_id_length;
        n_written += buffer.encode_varint (destination_id_length);
        n_written += buffer.encode_varint (26);
        var source_id_length = buffer.encode_string (this.source_id);
        n_written += source_id_length;
        n_written += buffer.encode_varint (source_id_length);
        n_written += buffer.encode_varint (18);
        n_written += buffer.encode_varint (this.protocol_version);
        n_written += buffer.encode_varint (8);

        return n_written;
    }

    public override string to_string (string indent = "")
    {
        var text = "";

        text += indent + "protocol_version: %s\n".printf (ProtocolVersion_to_string (this.protocol_version));
        text += indent + "source_id: %s\n".printf (Protobuf.string_to_string (this.source_id));
        text += indent + "destination_id: %s\n".printf (Protobuf.string_to_string (this.destination_id));
        text += indent + "namespace: %s\n".printf (Protobuf.string_to_string (this.namespace));
        text += indent + "payload_type: %s\n".printf (PayloadType_to_string (this.payload_type));
        text += indent + "payload_utf8: %s\n".printf (Protobuf.string_to_string (this.payload_utf8));
        text += indent + "payload_binary: %s\n".printf (Protobuf.bytes_to_string (this.payload_binary));

        return text;
    }
}

public class AuthChallenge : Protobuf.Message
{
    public SignatureAlgorithm signature_algorithm;
    public GLib.ByteArray sender_nonce;
    public HashAlgorithm hash_algorithm;

    public AuthChallenge ()
    {
        this.signature_algorithm = SignatureAlgorithm.RSASSA_PKCS1v15;
        this.sender_nonce = null;
        this.hash_algorithm = HashAlgorithm.SHA1;
    }

    public AuthChallenge.from_data (Protobuf.DecodeBuffer buffer, ssize_t data_length = -1)
    {
        decode (buffer, data_length);
    }

    public override bool decode (Protobuf.DecodeBuffer buffer, ssize_t data_length = -1)
    {
        size_t end;
        if (data_length < 0)
            end = buffer.buffer.length;
        else
            end = buffer.read_index + data_length;

        this.signature_algorithm = SignatureAlgorithm.RSASSA_PKCS1v15;
        this.sender_nonce = null;
        this.hash_algorithm = HashAlgorithm.SHA1;
        while (buffer.read_index < end)
        {
            var key = buffer.decode_varint ();
            var wire_type = key & 0x7;
            var field_number = key >> 3;

            if (field_number == 1 && wire_type == 0)
                this.signature_algorithm = (SignatureAlgorithm) buffer.decode_varint ();
            else if (field_number == 2 && wire_type == 2)
                this.sender_nonce = buffer.decode_bytes ((size_t) buffer.decode_varint ());
            else if (field_number == 3 && wire_type == 0)
                this.hash_algorithm = (HashAlgorithm) buffer.decode_varint ();
            else
                this.unknown_fields.prepend (buffer.decode_unknown_field (key));
        }

        if (buffer.read_index != end)
            buffer.error = true;

        return !buffer.error;
    }

    public override size_t encode (Protobuf.EncodeBuffer buffer)
    {
        size_t n_written = 0;

        foreach (var f in this.unknown_fields)
            n_written += buffer.encode_unknown_field (f);
        if (this.hash_algorithm != HashAlgorithm.SHA1)
        {
            n_written += buffer.encode_varint (this.hash_algorithm);
            n_written += buffer.encode_varint (24);
        }
        if (this.sender_nonce != null)
        {
            var sender_nonce_length = buffer.encode_bytes (this.sender_nonce);
            n_written += sender_nonce_length;
            n_written += buffer.encode_varint (sender_nonce_length);
            n_written += buffer.encode_varint (18);
        }
        if (this.signature_algorithm != SignatureAlgorithm.RSASSA_PKCS1v15)
        {
            n_written += buffer.encode_varint (this.signature_algorithm);
            n_written += buffer.encode_varint (8);
        }

        return n_written;
    }

    public override string to_string (string indent = "")
    {
        var text = "";

        text += indent + "signature_algorithm: %s\n".printf (SignatureAlgorithm_to_string (this.signature_algorithm));
        text += indent + "sender_nonce: %s\n".printf (Protobuf.bytes_to_string (this.sender_nonce));
        text += indent + "hash_algorithm: %s\n".printf (HashAlgorithm_to_string (this.hash_algorithm));

        return text;
    }
}

public class AuthResponse : Protobuf.Message
{
    public GLib.ByteArray signature;
    public GLib.ByteArray client_auth_certificate;
    public List<GLib.ByteArray> intermediate_certificate;
    public SignatureAlgorithm signature_algorithm;
    public GLib.ByteArray sender_nonce;
    public HashAlgorithm hash_algorithm;
    public GLib.ByteArray crl;

    public AuthResponse ()
    {
        this.signature = null;
        this.client_auth_certificate = null;
        this.intermediate_certificate = new List<GLib.ByteArray> ();
        this.signature_algorithm = SignatureAlgorithm.RSASSA_PKCS1v15;
        this.sender_nonce = null;
        this.hash_algorithm = HashAlgorithm.SHA1;
        this.crl = null;
    }

    public AuthResponse.from_data (Protobuf.DecodeBuffer buffer, ssize_t data_length = -1)
    {
        decode (buffer, data_length);
    }

    public override bool decode (Protobuf.DecodeBuffer buffer, ssize_t data_length = -1)
    {
        size_t end;
        if (data_length < 0)
            end = buffer.buffer.length;
        else
            end = buffer.read_index + data_length;
        var have_signature = false;
        var have_client_auth_certificate = false;

        this.signature = null;
        this.client_auth_certificate = null;
        this.intermediate_certificate = new List<GLib.ByteArray> ();
        this.signature_algorithm = SignatureAlgorithm.RSASSA_PKCS1v15;
        this.sender_nonce = null;
        this.hash_algorithm = HashAlgorithm.SHA1;
        this.crl = null;
        while (buffer.read_index < end)
        {
            var key = buffer.decode_varint ();
            var wire_type = key & 0x7;
            var field_number = key >> 3;

            if (field_number == 1 && wire_type == 2)
            {
                this.signature = buffer.decode_bytes ((size_t) buffer.decode_varint ());
                have_signature = true;
            }
            else if (field_number == 2 && wire_type == 2)
            {
                this.client_auth_certificate = buffer.decode_bytes ((size_t) buffer.decode_varint ());
                have_client_auth_certificate = true;
            }
            else if (field_number == 3 && wire_type == 2)
                this.intermediate_certificate.append (buffer.decode_bytes ((size_t) buffer.decode_varint ()));
            else if (field_number == 4 && wire_type == 0)
                this.signature_algorithm = (SignatureAlgorithm) buffer.decode_varint ();
            else if (field_number == 5 && wire_type == 2)
                this.sender_nonce = buffer.decode_bytes ((size_t) buffer.decode_varint ());
            else if (field_number == 6 && wire_type == 0)
                this.hash_algorithm = (HashAlgorithm) buffer.decode_varint ();
            else if (field_number == 7 && wire_type == 2)
                this.crl = buffer.decode_bytes ((size_t) buffer.decode_varint ());
            else
                this.unknown_fields.prepend (buffer.decode_unknown_field (key));
        }

        if (buffer.read_index != end)
            buffer.error = true;
        else if (!have_signature || !have_client_auth_certificate)
            buffer.error = true;

        return !buffer.error;
    }

    public override size_t encode (Protobuf.EncodeBuffer buffer)
    {
        size_t n_written = 0;

        foreach (var f in this.unknown_fields)
            n_written += buffer.encode_unknown_field (f);
        if (this.crl != null)
        {
            var crl_length = buffer.encode_bytes (this.crl);
            n_written += crl_length;
            n_written += buffer.encode_varint (crl_length);
            n_written += buffer.encode_varint (58);
        }
        if (this.hash_algorithm != HashAlgorithm.SHA1)
        {
            n_written += buffer.encode_varint (this.hash_algorithm);
            n_written += buffer.encode_varint (48);
        }
        if (this.sender_nonce != null)
        {
            var sender_nonce_length = buffer.encode_bytes (this.sender_nonce);
            n_written += sender_nonce_length;
            n_written += buffer.encode_varint (sender_nonce_length);
            n_written += buffer.encode_varint (42);
        }
        if (this.signature_algorithm != SignatureAlgorithm.RSASSA_PKCS1v15)
        {
            n_written += buffer.encode_varint (this.signature_algorithm);
            n_written += buffer.encode_varint (32);
        }
        for (unowned List<GLib.ByteArray> i = this.intermediate_certificate.last (); i != null; i = i.prev)
        {
            var intermediate_certificate_length = buffer.encode_bytes (i.data);
            n_written += intermediate_certificate_length;
            n_written += buffer.encode_varint (intermediate_certificate_length);
            n_written += buffer.encode_varint (26);
        }
        var client_auth_certificate_length = buffer.encode_bytes (this.client_auth_certificate);
        n_written += client_auth_certificate_length;
        n_written += buffer.encode_varint (client_auth_certificate_length);
        n_written += buffer.encode_varint (18);
        var signature_length = buffer.encode_bytes (this.signature);
        n_written += signature_length;
        n_written += buffer.encode_varint (signature_length);
        n_written += buffer.encode_varint (10);

        return n_written;
    }

    public override string to_string (string indent = "")
    {
        var text = "";

        text += indent + "signature: %s\n".printf (Protobuf.bytes_to_string (this.signature));
        text += indent + "client_auth_certificate: %s\n".printf (Protobuf.bytes_to_string (this.client_auth_certificate));
        foreach (unowned GLib.ByteArray v in this.intermediate_certificate)
        {
            text += indent + "intermediate_certificate: %s\n".printf (Protobuf.bytes_to_string (v));
        }
        text += indent + "signature_algorithm: %s\n".printf (SignatureAlgorithm_to_string (this.signature_algorithm));
        text += indent + "sender_nonce: %s\n".printf (Protobuf.bytes_to_string (this.sender_nonce));
        text += indent + "hash_algorithm: %s\n".printf (HashAlgorithm_to_string (this.hash_algorithm));
        text += indent + "crl: %s\n".printf (Protobuf.bytes_to_string (this.crl));

        return text;
    }
}

public class AuthError : Protobuf.Message
{
    public enum ErrorType
    {
        INTERNAL_ERROR = 0,
        NO_TLS = 1,
        SIGNATURE_ALGORITHM_UNAVAILABLE = 2,
    }
    public static string ErrorType_to_string (ErrorType value)
    {
        switch (value)
        {
        case ErrorType.INTERNAL_ERROR:
            return "INTERNAL_ERROR";
        case ErrorType.NO_TLS:
            return "NO_TLS";
        case ErrorType.SIGNATURE_ALGORITHM_UNAVAILABLE:
            return "SIGNATURE_ALGORITHM_UNAVAILABLE";
        default:
            return "%d".printf (value);
        }
    }
    public ErrorType error_type;

    public AuthError ()
    {
        this.error_type = 0;
    }

    public AuthError.from_data (Protobuf.DecodeBuffer buffer, ssize_t data_length = -1)
    {
        decode (buffer, data_length);
    }

    public override bool decode (Protobuf.DecodeBuffer buffer, ssize_t data_length = -1)
    {
        size_t end;
        if (data_length < 0)
            end = buffer.buffer.length;
        else
            end = buffer.read_index + data_length;
        var have_error_type = false;

        this.error_type = 0;
        while (buffer.read_index < end)
        {
            var key = buffer.decode_varint ();
            var wire_type = key & 0x7;
            var field_number = key >> 3;

            if (field_number == 1 && wire_type == 0)
            {
                this.error_type = (ErrorType) buffer.decode_varint ();
                have_error_type = true;
            }
            else
                this.unknown_fields.prepend (buffer.decode_unknown_field (key));
        }

        if (buffer.read_index != end)
            buffer.error = true;
        else if (!have_error_type)
            buffer.error = true;

        return !buffer.error;
    }

    public override size_t encode (Protobuf.EncodeBuffer buffer)
    {
        size_t n_written = 0;

        foreach (var f in this.unknown_fields)
            n_written += buffer.encode_unknown_field (f);
        n_written += buffer.encode_varint (this.error_type);
        n_written += buffer.encode_varint (8);

        return n_written;
    }

    public override string to_string (string indent = "")
    {
        var text = "";

        text += indent + "error_type: %s\n".printf (ErrorType_to_string (this.error_type));

        return text;
    }
}

public class DeviceAuthMessage : Protobuf.Message
{
    public AuthChallenge? challenge;
    public AuthResponse? response;
    public AuthError? error;

    public DeviceAuthMessage ()
    {
        this.challenge = null;
        this.response = null;
        this.error = null;
    }

    public DeviceAuthMessage.from_data (Protobuf.DecodeBuffer buffer, ssize_t data_length = -1)
    {
        decode (buffer, data_length);
    }

    public override bool decode (Protobuf.DecodeBuffer buffer, ssize_t data_length = -1)
    {
        size_t end;
        if (data_length < 0)
            end = buffer.buffer.length;
        else
            end = buffer.read_index + data_length;

        this.challenge = null;
        this.response = null;
        this.error = null;
        while (buffer.read_index < end)
        {
            var key = buffer.decode_varint ();
            var wire_type = key & 0x7;
            var field_number = key >> 3;

            if (field_number == 1 && wire_type == 2)
                this.challenge = new AuthChallenge.from_data (buffer, (ssize_t) buffer.decode_varint ());
            else if (field_number == 2 && wire_type == 2)
                this.response = new AuthResponse.from_data (buffer, (ssize_t) buffer.decode_varint ());
            else if (field_number == 3 && wire_type == 2)
                this.error = new AuthError.from_data (buffer, (ssize_t) buffer.decode_varint ());
            else
                this.unknown_fields.prepend (buffer.decode_unknown_field (key));
        }

        if (buffer.read_index != end)
            buffer.error = true;

        return !buffer.error;
    }

    public override size_t encode (Protobuf.EncodeBuffer buffer)
    {
        size_t n_written = 0;

        foreach (var f in this.unknown_fields)
            n_written += buffer.encode_unknown_field (f);
        if (this.error != null)
        {
            var error_length = this.error.encode (buffer);
            n_written += error_length;
            n_written += buffer.encode_varint (error_length);
            n_written += buffer.encode_varint (26);
        }
        if (this.response != null)
        {
            var response_length = this.response.encode (buffer);
            n_written += response_length;
            n_written += buffer.encode_varint (response_length);
            n_written += buffer.encode_varint (18);
        }
        if (this.challenge != null)
        {
            var challenge_length = this.challenge.encode (buffer);
            n_written += challenge_length;
            n_written += buffer.encode_varint (challenge_length);
            n_written += buffer.encode_varint (10);
        }

        return n_written;
    }

    public override string to_string (string indent = "")
    {
        var text = "";

        if (challenge != null)
        {
            text += indent + "challenge {\n";
            text += "%s".printf (this.challenge.to_string (indent + "  "));
            text += indent + "}\n";
        }
        if (response != null)
        {
            text += indent + "response {\n";
            text += "%s".printf (this.response.to_string (indent + "  "));
            text += indent + "}\n";
        }
        if (error != null)
        {
            text += indent + "error {\n";
            text += "%s".printf (this.error.to_string (indent + "  "));
            text += indent + "}\n";
        }

        return text;
    }
}
